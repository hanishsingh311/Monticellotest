'use strict';

// Export Plugin

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

module.exports = function (BasePlugin) {
	// Define Plugin
	return function (_BasePlugin) {
		_inherits(LessPlugin, _BasePlugin);

		function LessPlugin() {
			_classCallCheck(this, LessPlugin);

			return _possibleConstructorReturn(this, (LessPlugin.__proto__ || Object.getPrototypeOf(LessPlugin)).apply(this, arguments));
		}

		_createClass(LessPlugin, [{
			key: 'render',


			// Render the extensions [css].less with less
			value: function render(opts, next) {
				var inExtension = opts.inExtension,
				    outExtension = opts.outExtension,
				    file = opts.file;

				// Check extensions

				if (inExtension === 'less' && ['css', null].indexOf(outExtension) !== -1) {
					// Load the dependencies into memory now that we know we need them
					var less = require('less');
					var extendr = require('extendr');

					// Prepare our parser options to send to less by merging what we want with what the user has provided
					// http://lesscss.org/#using-less-configuration
					var lessOptions = extendr.extend({
						paths: [file.get('fullDirPath')],
						filename: file.get('fullPath')
					}, this.config.lessOptions || {});

					// If the less file references something else
					// then note that it references others
					// so that if something changes, this will also rerender
					// this is needed because less concats imports into one file
					if (this.config.referencesOthers !== false && opts.content.indexOf('@import') !== -1) {
						file.setMetaDefaults({ referenceOthers: true });
					}

					// now render the content with less css
					// http://lesscss.org/#using-less-usage-in-code
					less.render(opts.content, lessOptions, function (err, data) {
						if (err) return next(err);
						opts.content = data.css;
						next();
					});
				} else {
					next();
				}
			}
		}, {
			key: 'name',

			// Plugin name
			get: function get() {
				return 'less';
			}

			// Plugin initial config

		}, {
			key: 'initialConfig',
			get: function get() {
				return {
					referencesOthers: true,
					lessOptions: {
						compress: true,
						sourceMap: false
					},
					environments: {
						development: {
							lessOptions: {
								compress: false,
								sourceMap: {
									sourceMapFileInline: true
								}
							}
						}
					}
				};
			}
		}]);

		return LessPlugin;
	}(BasePlugin);
};